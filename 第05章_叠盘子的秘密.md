# 第05章 叠盘子的秘密

*栈如同我们叠起的盘子，最后放上的总是最先被拿走。生活中的许多美好瞬间也是如此——最近的回忆总是最容易想起，而深埋的往事需要我们一层层地回溯。*

周五的午后，DSA Lab意外地安静。安妮独自坐在角落里，面前摆着一个奇怪的"建筑"——用实验室的咖啡杯和小盘子搭成的高塔，看起来摇摇欲坠。

"这是什么东西？"黛芙推门进来，银发上还带着些许雨珠，显然刚从外面回来，"安妮，你在搞艺术创作？"

安妮抬起头，眼中闪着兴奋的光芒："黛芙姐！我在想昨天你说的那个'叠盘子'的栈，就想试试看真正叠盘子是什么感觉。"

黛芙走近看了看，忍不住笑了："你这个塔快要倒了吧？而且......"她指着最下面，"为什么最底下是我的咖啡杯？"

"咦？"安妮有点慌，"因为、因为它最大最稳？"

"那是我最爱的马克杯！"黛芙佯装生气，但眼中有笑意，"如果你想拿我的杯子，至少得先把上面的都拿掉吧？"

安妮伸手想直接抽出底下的杯子，整个塔立刻开始晃动。

"等等等等！"黛芙连忙阻止，"你这样会全塌的！这就是栈的核心特点——后进先出，Last In First Out，简称LIFO。"

"啊？"安妮停下手，疑惑地看着她。

这时希娅也进来了，看到这个情景忍不住捂嘴轻笑："看起来有人在用最直观的方式学习数据结构呢。"

"希娅姐！"安妮有点不好意思，"我只是想体验一下栈的感觉，但是......好像搞砸了。"

希娅走过来，仔细观察了这个摇摇欲坠的塔："其实你的想法很对。栈确实像叠盘子，但重点不是叠多高，而是理解它的规则。"

她轻柔地从最上面拿下一个小碟子："看，我们只能从顶部操作。这个操作叫做......?"

"pop？"安妮试探性地说。

"对！"希娅微笑，"从栈顶移除元素叫pop。那如果我要放一个新碟子呢？"

"push！放到最顶上！"安妮立刻回答。

黛芙这时也被她们的互动逗乐了："不错，看来昨天没白听。不过，安妮，你知道为什么我刚才说不能直接拿底下的杯子吗？"

安妮想了想："因为......因为栈只能在一端操作？就像这个塔，我只能从上面拿？"

"聪明！"黛芙赞许地点点头，"但现在我有个问题——如果我真的很想要我的杯子，但又不想让其他杯子掉到地上摔碎，你会怎么办？"

安妮眨眨眼，突然灵光一闪："我知道了！我要先把上面的都拿下来，小心地放到别的地方，然后拿你的杯子，再把其他的按原来的顺序放回去！"

"exactly！"黛芙眼中闪过赞赏，"这就是栈的一个重要应用场景——有时候我们需要暂时移除一些元素来访问底部的元素，然后再按相反的顺序放回去。"

这时，伊莎贝尔也到了，她看到三人围着这个杯子塔讨论，好奇地问："你们在进行栈的物理建模吗？"

"伊莎贝尔！"安妮兴奋地转向她，"我们在学栈的操作！但是我有个疑问——"

她指着黛芙的马克杯："如果我想知道最底下是什么，但又不想真的拿出来，有办法吗？"

伊莎贝尔思考了一下："在栈这个数据结构中，我们通常只能看到栈顶的元素。有一个操作叫peek或者top，可以查看栈顶元素但不移除它。"

"但是底部的元素呢？"安妮追问。

"那就需要把上面的都pop出来了。"伊莎贝尔微笑，"除非......"

她故意停顿了一下，在白板上画了个图：

```
栈的状态：
     ┌─────┐  ← 栈顶 (最后进入)
     │ 🥛  │
     ├─────┤
     │ 🍽️  │
     ├─────┤
     │ ☕  │  ← 栈底 (最先进入)
     └─────┘

操作：
push(🧃) → 在顶部添加新元素
pop()     → 移除并返回顶部元素
peek()    → 查看顶部元素但不移除
```

"除非什么？"安妮好奇地问。

伊莎贝尔神秘地笑了笑："除非我们使用辅助栈。比如，如果我们想找到栈底的元素，可以创建一个临时栈，把原栈的元素一个个pop出来push到临时栈里，这样原来的栈底就变成了临时栈的栈顶。"

黛芙突然想到什么："等等，说到这个，我想起一个有趣的问题。安妮，如果我现在给你两个栈，你能用它们模拟一个队列吗？"

"队列？"安妮眼中露出困惑，"那不是下一章要学的吗？"

"队列就是先进先出，"希娅解释道，"像排队买奶茶一样，最先排队的最先买到。"

安妮皱着眉头思考："栈是后进先出，队列是先进先出......"她看着桌上的杯子塔，"这怎么可能？完全相反啊！"

黛芙眼中闪过狡黠的光芒："这是个经典的面试题呢。提示一下——如果你有两个栈，一个用来接收新元素，另一个用来输出元素......"

安妮的眼睛渐渐亮了起来："我懂了！新来的元素都放到第一个栈，要取元素的时候，如果第二个栈是空的，就把第一个栈的所有元素都倒到第二个栈里！"

她激动地比划着："这样第一个栈里最底下的元素就变成了第二个栈最顶上的，然后我从第二个栈pop出来的就是最早进入的元素！"

"brilliant！"伊莎贝尔鼓掌，"这就是用栈实现队列的经典方法。"

希娅补充道："而且在浏览器历史记录中，是用两个栈来实现前进后退功能的——一个后退栈，一个前进栈。"

"原来如此！"安妮恍然大悟，"难怪昨天黛芙姐说浏览器历史记录是用栈实现的！"

黛芙看时间差不多了，决定让安妮看一些实际的代码。她在白板上写道：

```python
# 栈的基本实现 - 像管理一摞盘子
class Stack:
    def __init__(self):
        self.items = []  # 用列表模拟栈，右边是栈顶
    
    def is_empty(self):
        return len(self.items) == 0  # 检查栈是否为空
    
    def push(self, item):
        self.items.append(item)  # 在栈顶添加元素
        print(f"📍 推入: {item}, 栈现在: {self.items}")
    
    def pop(self):
        if self.is_empty():
            raise IndexError("栈是空的，无法pop！")
        item = self.items.pop()  # 移除并返回栈顶元素
        print(f"🎯 弹出: {item}, 栈现在: {self.items}")
        return item
    
    def peek(self):
        if self.is_empty():
            raise IndexError("栈是空的，无法peek！")
        return self.items[-1]  # 查看栈顶元素但不移除
    
    def size(self):
        return len(self.items)  # 返回栈的大小

# 用两个栈实现队列 - 黛芙的挑战题
class QueueUsingStacks:
    def __init__(self):
        self.input_stack = Stack()   # 接收新元素的栈
        self.output_stack = Stack()  # 输出元素的栈
    
    def enqueue(self, item):
        # 新元素总是放到input_stack
        self.input_stack.push(item)
        print(f"🔄 入队: {item}")
    
    def dequeue(self):
        # 如果output_stack是空的，把input_stack的元素都倒过去
        if self.output_stack.is_empty():
            while not self.input_stack.is_empty():
                self.output_stack.push(self.input_stack.pop())
        
        # 从output_stack弹出元素
        if self.output_stack.is_empty():
            raise IndexError("队列是空的！")
        
        item = self.output_stack.pop()
        print(f"🎯 出队: {item}")
        return item
```

"哇！"安妮看着代码，眼中突然闪过疑惑，"等等，这里有个奇怪的东西——`self.items[-1]`，为什么是-1？负数也能当索引吗？"

希娅温柔地笑了："这是Python的一个贴心设计呢。安妮，你觉得如果要拿到杯子塔最顶上的杯子，你会怎么形容它的位置？"

"嗯......"安妮想了想，"我会说'最上面那个'或者'最后放上去的那个'？"

"没错！"希娅在白板上画了个示意图：

```python
items = ["☕杯子1", "🍽️盘子", "🥛杯子2", "🧃果汁盒"]
#         0        1       2        3     ← 正向索引
#        -4       -3      -2       -1     ← 负向索引（从后往前数）

items[3]   # 🧃果汁盒 (第4个位置)
items[-1]  # 🧃果汁盒 (倒数第1个，也就是最后一个)
items[-2]  # 🥛杯子2 (倒数第2个)
```

"哦！"安妮眼睛发亮，"所以-1就是'最后一个'的意思！这样写比`items[len(items)-1]`简单多了！"

"exactly！"黛芙赞许地说，"这就像你直接说'最顶上那个杯子'，而不需要数'第几个杯子'一样自然。"

伊莎贝尔接着解释："而且，对于栈来说，我们最关心的就是'最后一个'——也就是栈顶元素。用`-1`让代码读起来更像人话。"

"原来如此！"安妮继续看代码，"用列表就能实现栈！append是push，pop是pop，太巧了！"

"没错，"伊莎贝尔说，"Python的列表天然支持栈操作。不过这里有个重要的性能问题——"

她在白板上画了另一个图：

```
列表在内存中的存储：
┌──────┬──────┬──────┬──────┬──────┐
│ 元素0 │ 元素1 │ 元素2 │ 元素3 │ 空位 │
└──────┴──────┴──────┴──────┴──────┘
 ↑开头                        ↑末尾
 索引0                        索引3

在末尾操作（栈顶）：
append(): 直接在末尾加元素 → O(1) 很快！
pop():    直接删除末尾元素 → O(1) 很快！

在开头操作（栈底）：
insert(0, x): 所有元素都要往后挪一位 → O(n) 很慢！
pop(0):       所有元素都要往前挪一位 → O(n) 很慢！
```

安妮看着图，若有所思："所以末尾是指列表的最后位置，也就是我们栈的顶部？开头是指列表的第一个位置，也就是栈底？"

"完全正确！"希娅点头，"想象一下，如果你要在杯子塔的最顶上加一个杯子，只需要轻轻放上去就行了。但如果你要在杯子塔的最底下加一个杯子......"

"那就要把上面的杯子全部拿起来，放下新杯子，再把所有杯子一个个放回去！"安妮恍然大悟，"太麻烦了！"

黛芙补充道："这就是为什么我们说在列表末尾操作是O(1)——只需要一步，而在开头操作是O(n)——需要移动n个元素。"

"所以，"安妮总结道，"用列表实现栈的时候，我们把列表的末尾当作栈顶，这样push和pop都很快！"

"聪明！"伊莎贝尔鼓掌。

黛芙指着QueueUsingStacks的代码："看出来这个队列实现的巧妙之处了吗？"

安妮仔细研究："输入栈负责接收，输出栈负责发送。当输出栈空了，就把输入栈的元素全部倒过去，这样顺序就反过来了！"

她们测试了一下：

```python
# 测试栈
plate_stack = Stack()
plate_stack.push("🍽️盘子1")
plate_stack.push("🍽️盘子2") 
plate_stack.push("🍽️盘子3")

print("栈顶:", plate_stack.peek())  # 盘子3
plate_stack.pop()  # 盘子3
plate_stack.pop()  # 盘子2

# 测试队列
queue = QueueUsingStacks()
queue.enqueue("客人A")
queue.enqueue("客人B")
queue.enqueue("客人C")

queue.dequeue()  # 客人A (最先进入的最先出来)
queue.dequeue()  # 客人B
```

"太神奇了！"安妮拍手，"真的实现了先进先出！不过......"

她突然想到什么，脸上露出担忧的表情："黛芙姐，你的马克杯还在我的塔底下压着呢......"

四人转头看向那个摇摇欲坠的杯子塔，黛芙哈哈大笑："现在你知道该怎么安全地拿出来了吧？"

安妮小心翼翼地一个个从顶部拿下杯子，放到旁边："pop... pop... pop... 终于拿到黛芙姐的杯子了！"

她举起那个马克杯，上面写着"Coffee++; Life.compile();"的程序员笑话。

"这个杯子也很有个性呢，"希娅笑道，"就像我们的栈一样，有着清晰的逻辑和规则。"

"那么，"伊莎贝尔看着安妮，"下次我们学队列的时候，你还会搭实物模型吗？"

安妮想了想，眼中又闪起了光芒："当然！不过下次我要搭一个排队的模型，最好是......"

"最好是什么？"黛芙好奇地问。

"最好是搭一个奶茶店的队伍！"安妮开心地说，"这样学习的时候还能想象喝奶茶的快乐！"

四个女孩都笑了。她们发现，有时候最简单的实验往往能带来最深刻的理解。就像栈一样，看似简单的后进先出原则，却能解决许多复杂的计算机问题。

黛芙看着整理好的杯子们，若有所思地说："其实栈在计算机中无处不在——函数调用栈、表达式求值、括号匹配......"

"真的吗？"安妮好奇地问。

"当然，"黛芙的眼中闪过一丝神秘，"比如说，当你写递归函数的时候，计算机就是用栈来记住每次函数调用的状态的。"

"递归？"安妮眨眨眼，"那又是什么？"

"那个..."伊莎贝尔微笑道，"就是下次的惊喜了。"

> 栈（Stack）：后进先出（LIFO）的线性数据结构，仅允许在栈顶进行插入和删除操作，广泛应用于函数调用、表达式求值等场景。

> 推荐练习题：LeetCode 20.有效的括号, 155.最小栈, 225.用队列实现栈, 232.用栈实现队列, 739.每日温度 